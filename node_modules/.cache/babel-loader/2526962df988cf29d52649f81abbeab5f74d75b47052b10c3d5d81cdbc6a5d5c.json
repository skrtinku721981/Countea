{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkExact = checkExact;\nconst base_1 = require(\"../base\");\nconst chain_1 = require(\"../chain\");\nconst context_1 = require(\"../context\");\nconst field_selection_1 = require(\"../field-selection\");\nconst utils_1 = require(\"../utils\");\n/**\n * Checks whether the request contains exactly only those fields that have been validated.\n *\n * Unknown fields, if found, will generate an error of type `unknown_fields`.\n *\n * @param chains either a single chain, an array of chains, or a mixed array of chains and array of chains.\n *               This means that all of the below are valid:\n * ```\n * checkExact(check('foo'))\n * checkExact([check('foo'), check('bar')])\n * checkExact([check('foo'), check('bar')])\n * checkExact(checkSchema({ ... }))\n * checkExact([checkSchema({ ... }), check('foo')])\n * ```\n * @param opts\n */\nfunction checkExact(chains, opts) {\n  // Don't include all locations by default. Browsers will add cookies and headers that the user\n  // might not want to validate, which would be a footgun.\n  const locations = opts?.locations || ['body', 'params', 'query'];\n  const chainsArr = Array.isArray(chains) ? chains.flat() : chains ? [chains] : [];\n  const run = async req => {\n    const internalReq = req;\n    const fieldsByLocation = new Map();\n    await (0, utils_1.runAllChains)(req, chainsArr);\n    // The chains above will have added contexts to the request\n    (internalReq[base_1.contextsKey] || []).forEach(context => {\n      context.locations.forEach(location => {\n        if (!locations.includes(location)) {\n          return;\n        }\n        const locationFields = fieldsByLocation.get(location) || [];\n        locationFields.push(...context.fields);\n        fieldsByLocation.set(location, locationFields);\n      });\n    });\n    // when none of the chains matched anything, then everything is unknown.\n    if (!fieldsByLocation.size) {\n      locations.forEach(location => fieldsByLocation.set(location, []));\n    }\n    let unknownFields = [];\n    for (const [location, fields] of fieldsByLocation.entries()) {\n      unknownFields = unknownFields.concat((0, field_selection_1.selectUnknownFields)(req, fields, [location]));\n    }\n    const context = new context_1.Context([], [], [], false, false);\n    if (unknownFields.length) {\n      context.addError({\n        type: 'unknown_fields',\n        req,\n        message: opts?.message || 'Unknown field(s)',\n        fields: unknownFields\n      });\n    }\n    internalReq[base_1.contextsKey] = internalReq[base_1.contextsKey] || [];\n    internalReq[base_1.contextsKey].push(context);\n    return new chain_1.ResultWithContextImpl(context);\n  };\n  const middleware = (req, _res, next) => run(req).then(() => next(), next);\n  return Object.assign(middleware, {\n    run\n  });\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","checkExact","base_1","require","chain_1","context_1","field_selection_1","utils_1","chains","opts","locations","chainsArr","Array","isArray","flat","run","req","internalReq","fieldsByLocation","Map","runAllChains","contextsKey","forEach","context","location","includes","locationFields","get","push","fields","set","size","unknownFields","entries","concat","selectUnknownFields","Context","length","addError","type","message","ResultWithContextImpl","middleware","_res","next","then","assign"],"sources":["D:/test/textutils/node_modules/express-validator/lib/middlewares/exact.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkExact = checkExact;\nconst base_1 = require(\"../base\");\nconst chain_1 = require(\"../chain\");\nconst context_1 = require(\"../context\");\nconst field_selection_1 = require(\"../field-selection\");\nconst utils_1 = require(\"../utils\");\n/**\n * Checks whether the request contains exactly only those fields that have been validated.\n *\n * Unknown fields, if found, will generate an error of type `unknown_fields`.\n *\n * @param chains either a single chain, an array of chains, or a mixed array of chains and array of chains.\n *               This means that all of the below are valid:\n * ```\n * checkExact(check('foo'))\n * checkExact([check('foo'), check('bar')])\n * checkExact([check('foo'), check('bar')])\n * checkExact(checkSchema({ ... }))\n * checkExact([checkSchema({ ... }), check('foo')])\n * ```\n * @param opts\n */\nfunction checkExact(chains, opts) {\n    // Don't include all locations by default. Browsers will add cookies and headers that the user\n    // might not want to validate, which would be a footgun.\n    const locations = opts?.locations || ['body', 'params', 'query'];\n    const chainsArr = Array.isArray(chains) ? chains.flat() : chains ? [chains] : [];\n    const run = async (req) => {\n        const internalReq = req;\n        const fieldsByLocation = new Map();\n        await (0, utils_1.runAllChains)(req, chainsArr);\n        // The chains above will have added contexts to the request\n        (internalReq[base_1.contextsKey] || []).forEach(context => {\n            context.locations.forEach(location => {\n                if (!locations.includes(location)) {\n                    return;\n                }\n                const locationFields = fieldsByLocation.get(location) || [];\n                locationFields.push(...context.fields);\n                fieldsByLocation.set(location, locationFields);\n            });\n        });\n        // when none of the chains matched anything, then everything is unknown.\n        if (!fieldsByLocation.size) {\n            locations.forEach(location => fieldsByLocation.set(location, []));\n        }\n        let unknownFields = [];\n        for (const [location, fields] of fieldsByLocation.entries()) {\n            unknownFields = unknownFields.concat((0, field_selection_1.selectUnknownFields)(req, fields, [location]));\n        }\n        const context = new context_1.Context([], [], [], false, false);\n        if (unknownFields.length) {\n            context.addError({\n                type: 'unknown_fields',\n                req,\n                message: opts?.message || 'Unknown field(s)',\n                fields: unknownFields,\n            });\n        }\n        internalReq[base_1.contextsKey] = internalReq[base_1.contextsKey] || [];\n        internalReq[base_1.contextsKey].push(context);\n        return new chain_1.ResultWithContextImpl(context);\n    };\n    const middleware = (req, _res, next) => run(req).then(() => next(), next);\n    return Object.assign(middleware, { run });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}