{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ContextRunnerImpl = exports.ResultWithContextImpl = void 0;\nconst _ = require(\"lodash\");\nconst base_1 = require(\"../base\");\nconst context_1 = require(\"../context\");\nconst field_selection_1 = require(\"../field-selection\");\nconst validation_result_1 = require(\"../validation-result\");\nclass ResultWithContextImpl extends validation_result_1.Result {\n  constructor(context) {\n    super(error => error, context.errors);\n    this.context = context;\n  }\n}\nexports.ResultWithContextImpl = ResultWithContextImpl;\nclass ContextRunnerImpl {\n  constructor(builderOrContext, selectFields = field_selection_1.selectFields) {\n    this.builderOrContext = builderOrContext;\n    this.selectFields = selectFields;\n  }\n  async run(req, options = {}) {\n    const context = this.builderOrContext instanceof context_1.Context ? this.builderOrContext : this.builderOrContext.build();\n    const internalReq = req;\n    const bail = internalReq[base_1.contextsKey]?.some(context => context.bail && context.errors.length > 0);\n    if (bail) {\n      return new ResultWithContextImpl(context);\n    }\n    const instances = this.selectFields(req, context.fields, context.locations);\n    context.addFieldInstances(instances);\n    const haltedInstances = new Set();\n    for (const contextItem of context.stack) {\n      const promises = context.getData({\n        requiredOnly: true\n      }).map(async instance => {\n        const {\n          location,\n          path\n        } = instance;\n        const instanceKey = `${location}:${path}`;\n        if (haltedInstances.has(instanceKey)) {\n          return;\n        }\n        try {\n          await contextItem.run(context, instance.value, {\n            req,\n            location,\n            path,\n            pathValues: instance.pathValues\n          });\n          // An instance is mutable, so if an item changed its value, there's no need to call getData again\n          const newValue = instance.value;\n          // Checks whether the value changed.\n          // Avoids e.g. undefined values being set on the request if it didn't have the key initially.\n          const reqValue = path !== '' ? _.get(req[location], path) : req[location];\n          if (!options.dryRun && reqValue !== instance.value) {\n            path !== '' ? _.set(req[location], path, newValue) : _.set(req, location, newValue);\n          }\n        } catch (e) {\n          if (e instanceof base_1.ValidationHalt) {\n            haltedInstances.add(instanceKey);\n            return;\n          }\n          throw e;\n        }\n      });\n      await Promise.all(promises);\n    }\n    if (!options.dryRun) {\n      internalReq[base_1.contextsKey] = (internalReq[base_1.contextsKey] || []).concat(context);\n    }\n    return new ResultWithContextImpl(context);\n  }\n}\nexports.ContextRunnerImpl = ContextRunnerImpl;","map":{"version":3,"names":["Object","defineProperty","exports","value","ContextRunnerImpl","ResultWithContextImpl","_","require","base_1","context_1","field_selection_1","validation_result_1","Result","constructor","context","error","errors","builderOrContext","selectFields","run","req","options","Context","build","internalReq","bail","contextsKey","some","length","instances","fields","locations","addFieldInstances","haltedInstances","Set","contextItem","stack","promises","getData","requiredOnly","map","instance","location","path","instanceKey","has","pathValues","newValue","reqValue","get","dryRun","set","e","ValidationHalt","add","Promise","all","concat"],"sources":["D:/test/textutils/node_modules/express-validator/lib/chain/context-runner-impl.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContextRunnerImpl = exports.ResultWithContextImpl = void 0;\nconst _ = require(\"lodash\");\nconst base_1 = require(\"../base\");\nconst context_1 = require(\"../context\");\nconst field_selection_1 = require(\"../field-selection\");\nconst validation_result_1 = require(\"../validation-result\");\nclass ResultWithContextImpl extends validation_result_1.Result {\n    constructor(context) {\n        super(error => error, context.errors);\n        this.context = context;\n    }\n}\nexports.ResultWithContextImpl = ResultWithContextImpl;\nclass ContextRunnerImpl {\n    constructor(builderOrContext, selectFields = field_selection_1.selectFields) {\n        this.builderOrContext = builderOrContext;\n        this.selectFields = selectFields;\n    }\n    async run(req, options = {}) {\n        const context = this.builderOrContext instanceof context_1.Context\n            ? this.builderOrContext\n            : this.builderOrContext.build();\n        const internalReq = req;\n        const bail = internalReq[base_1.contextsKey]?.some(context => context.bail && context.errors.length > 0);\n        if (bail) {\n            return new ResultWithContextImpl(context);\n        }\n        const instances = this.selectFields(req, context.fields, context.locations);\n        context.addFieldInstances(instances);\n        const haltedInstances = new Set();\n        for (const contextItem of context.stack) {\n            const promises = context.getData({ requiredOnly: true }).map(async (instance) => {\n                const { location, path } = instance;\n                const instanceKey = `${location}:${path}`;\n                if (haltedInstances.has(instanceKey)) {\n                    return;\n                }\n                try {\n                    await contextItem.run(context, instance.value, {\n                        req,\n                        location,\n                        path,\n                        pathValues: instance.pathValues,\n                    });\n                    // An instance is mutable, so if an item changed its value, there's no need to call getData again\n                    const newValue = instance.value;\n                    // Checks whether the value changed.\n                    // Avoids e.g. undefined values being set on the request if it didn't have the key initially.\n                    const reqValue = path !== '' ? _.get(req[location], path) : req[location];\n                    if (!options.dryRun && reqValue !== instance.value) {\n                        path !== '' ? _.set(req[location], path, newValue) : _.set(req, location, newValue);\n                    }\n                }\n                catch (e) {\n                    if (e instanceof base_1.ValidationHalt) {\n                        haltedInstances.add(instanceKey);\n                        return;\n                    }\n                    throw e;\n                }\n            });\n            await Promise.all(promises);\n        }\n        if (!options.dryRun) {\n            internalReq[base_1.contextsKey] = (internalReq[base_1.contextsKey] || []).concat(context);\n        }\n        return new ResultWithContextImpl(context);\n    }\n}\nexports.ContextRunnerImpl = ContextRunnerImpl;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}