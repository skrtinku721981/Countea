{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.oneOf = oneOf;\nconst _ = require(\"lodash\");\nconst chain_1 = require(\"../chain\");\nconst context_builder_1 = require(\"../context-builder\");\nconst utils_1 = require(\"../utils\");\n// A dummy context item that gets added to surrogate contexts just to make them run\nconst dummyItem = {\n  async run() {}\n};\n/**\n * Creates a middleware that will ensure that at least one of the given validation chains\n * or validation chain groups are valid.\n *\n * If none are, a single `AlternativeValidationError` or `GroupedAlternativeValidationError`\n * is added to the request, with the errors of each chain made available under the `nestedErrors` property.\n *\n * @param chains an array of validation chains to check if are valid.\n *               If any of the items of `chains` is an array of validation chains, then all of them\n *               must be valid together for the request to be considered valid.\n */\nfunction oneOf(chains, options = {}) {\n  const run = async (req, opts) => {\n    const surrogateContext = new context_builder_1.ContextBuilder().addItem(dummyItem).build();\n    // Run each group of chains in parallel\n    const promises = chains.map(async chain => {\n      const group = Array.isArray(chain) ? chain : [chain];\n      const results = await (0, utils_1.runAllChains)(req, group, {\n        dryRun: true\n      });\n      const {\n        contexts,\n        groupErrors\n      } = results.reduce(({\n        contexts,\n        groupErrors\n      }, result) => {\n        const {\n          context\n        } = result;\n        contexts.push(context);\n        const fieldErrors = context.errors.filter(error => error.type === 'field');\n        groupErrors.push(...fieldErrors);\n        return {\n          contexts,\n          groupErrors\n        };\n      }, {\n        contexts: [],\n        groupErrors: []\n      });\n      // #536: The data from a chain within oneOf() can only be made available to e.g. matchedData()\n      // if its entire group is valid.\n      if (!groupErrors.length) {\n        contexts.forEach(context => {\n          surrogateContext.addFieldInstances(context.getData());\n        });\n      }\n      return groupErrors;\n    });\n    const allErrors = await Promise.all(promises);\n    const success = allErrors.some(groupErrors => groupErrors.length === 0);\n    if (!success) {\n      const message = options.message || 'Invalid value(s)';\n      switch (options.errorType) {\n        case 'flat':\n          surrogateContext.addError({\n            type: 'alternative',\n            req,\n            message,\n            nestedErrors: _.flatMap(allErrors)\n          });\n          break;\n        case 'least_errored':\n          let leastErroredIndex = 0;\n          for (let i = 1; i < allErrors.length; i++) {\n            if (allErrors[i].length < allErrors[leastErroredIndex].length) {\n              leastErroredIndex = i;\n            }\n          }\n          surrogateContext.addError({\n            type: 'alternative',\n            req,\n            message,\n            nestedErrors: allErrors[leastErroredIndex]\n          });\n          break;\n        case 'grouped':\n        default:\n          // grouped\n          surrogateContext.addError({\n            type: 'alternative_grouped',\n            req,\n            message,\n            nestedErrors: allErrors\n          });\n          break;\n      }\n    }\n    // Final context running pass to ensure contexts are added and values are modified properly\n    return await new chain_1.ContextRunnerImpl(surrogateContext).run(req, opts);\n  };\n  const middleware = (req, _res, next) => run(req).then(() => next(), next);\n  return Object.assign(middleware, {\n    run\n  });\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","oneOf","_","require","chain_1","context_builder_1","utils_1","dummyItem","run","chains","options","req","opts","surrogateContext","ContextBuilder","addItem","build","promises","map","chain","group","Array","isArray","results","runAllChains","dryRun","contexts","groupErrors","reduce","result","context","push","fieldErrors","errors","filter","error","type","length","forEach","addFieldInstances","getData","allErrors","Promise","all","success","some","message","errorType","addError","nestedErrors","flatMap","leastErroredIndex","i","ContextRunnerImpl","middleware","_res","next","then","assign"],"sources":["D:/test/textutils/node_modules/express-validator/lib/middlewares/one-of.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.oneOf = oneOf;\nconst _ = require(\"lodash\");\nconst chain_1 = require(\"../chain\");\nconst context_builder_1 = require(\"../context-builder\");\nconst utils_1 = require(\"../utils\");\n// A dummy context item that gets added to surrogate contexts just to make them run\nconst dummyItem = { async run() { } };\n/**\n * Creates a middleware that will ensure that at least one of the given validation chains\n * or validation chain groups are valid.\n *\n * If none are, a single `AlternativeValidationError` or `GroupedAlternativeValidationError`\n * is added to the request, with the errors of each chain made available under the `nestedErrors` property.\n *\n * @param chains an array of validation chains to check if are valid.\n *               If any of the items of `chains` is an array of validation chains, then all of them\n *               must be valid together for the request to be considered valid.\n */\nfunction oneOf(chains, options = {}) {\n    const run = async (req, opts) => {\n        const surrogateContext = new context_builder_1.ContextBuilder().addItem(dummyItem).build();\n        // Run each group of chains in parallel\n        const promises = chains.map(async (chain) => {\n            const group = Array.isArray(chain) ? chain : [chain];\n            const results = await (0, utils_1.runAllChains)(req, group, { dryRun: true });\n            const { contexts, groupErrors } = results.reduce(({ contexts, groupErrors }, result) => {\n                const { context } = result;\n                contexts.push(context);\n                const fieldErrors = context.errors.filter((error) => error.type === 'field');\n                groupErrors.push(...fieldErrors);\n                return { contexts, groupErrors };\n            }, {\n                contexts: [],\n                groupErrors: [],\n            });\n            // #536: The data from a chain within oneOf() can only be made available to e.g. matchedData()\n            // if its entire group is valid.\n            if (!groupErrors.length) {\n                contexts.forEach(context => {\n                    surrogateContext.addFieldInstances(context.getData());\n                });\n            }\n            return groupErrors;\n        });\n        const allErrors = await Promise.all(promises);\n        const success = allErrors.some(groupErrors => groupErrors.length === 0);\n        if (!success) {\n            const message = options.message || 'Invalid value(s)';\n            switch (options.errorType) {\n                case 'flat':\n                    surrogateContext.addError({\n                        type: 'alternative',\n                        req,\n                        message,\n                        nestedErrors: _.flatMap(allErrors),\n                    });\n                    break;\n                case 'least_errored':\n                    let leastErroredIndex = 0;\n                    for (let i = 1; i < allErrors.length; i++) {\n                        if (allErrors[i].length < allErrors[leastErroredIndex].length) {\n                            leastErroredIndex = i;\n                        }\n                    }\n                    surrogateContext.addError({\n                        type: 'alternative',\n                        req,\n                        message,\n                        nestedErrors: allErrors[leastErroredIndex],\n                    });\n                    break;\n                case 'grouped':\n                default:\n                    // grouped\n                    surrogateContext.addError({\n                        type: 'alternative_grouped',\n                        req,\n                        message,\n                        nestedErrors: allErrors,\n                    });\n                    break;\n            }\n        }\n        // Final context running pass to ensure contexts are added and values are modified properly\n        return await new chain_1.ContextRunnerImpl(surrogateContext).run(req, opts);\n    };\n    const middleware = (req, _res, next) => run(req).then(() => next(), next);\n    return Object.assign(middleware, { run });\n}\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,KAAK,GAAGA,KAAK;AACrB,MAAMC,CAAC,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAC3B,MAAMC,OAAO,GAAGD,OAAO,CAAC,UAAU,CAAC;AACnC,MAAME,iBAAiB,GAAGF,OAAO,CAAC,oBAAoB,CAAC;AACvD,MAAMG,OAAO,GAAGH,OAAO,CAAC,UAAU,CAAC;AACnC;AACA,MAAMI,SAAS,GAAG;EAAE,MAAMC,GAAGA,CAAA,EAAG,CAAE;AAAE,CAAC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASP,KAAKA,CAACQ,MAAM,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EACjC,MAAMF,GAAG,GAAG,MAAAA,CAAOG,GAAG,EAAEC,IAAI,KAAK;IAC7B,MAAMC,gBAAgB,GAAG,IAAIR,iBAAiB,CAACS,cAAc,CAAC,CAAC,CAACC,OAAO,CAACR,SAAS,CAAC,CAACS,KAAK,CAAC,CAAC;IAC1F;IACA,MAAMC,QAAQ,GAAGR,MAAM,CAACS,GAAG,CAAC,MAAOC,KAAK,IAAK;MACzC,MAAMC,KAAK,GAAGC,KAAK,CAACC,OAAO,CAACH,KAAK,CAAC,GAAGA,KAAK,GAAG,CAACA,KAAK,CAAC;MACpD,MAAMI,OAAO,GAAG,MAAM,CAAC,CAAC,EAAEjB,OAAO,CAACkB,YAAY,EAAEb,GAAG,EAAES,KAAK,EAAE;QAAEK,MAAM,EAAE;MAAK,CAAC,CAAC;MAC7E,MAAM;QAAEC,QAAQ;QAAEC;MAAY,CAAC,GAAGJ,OAAO,CAACK,MAAM,CAAC,CAAC;QAAEF,QAAQ;QAAEC;MAAY,CAAC,EAAEE,MAAM,KAAK;QACpF,MAAM;UAAEC;QAAQ,CAAC,GAAGD,MAAM;QAC1BH,QAAQ,CAACK,IAAI,CAACD,OAAO,CAAC;QACtB,MAAME,WAAW,GAAGF,OAAO,CAACG,MAAM,CAACC,MAAM,CAAEC,KAAK,IAAKA,KAAK,CAACC,IAAI,KAAK,OAAO,CAAC;QAC5ET,WAAW,CAACI,IAAI,CAAC,GAAGC,WAAW,CAAC;QAChC,OAAO;UAAEN,QAAQ;UAAEC;QAAY,CAAC;MACpC,CAAC,EAAE;QACCD,QAAQ,EAAE,EAAE;QACZC,WAAW,EAAE;MACjB,CAAC,CAAC;MACF;MACA;MACA,IAAI,CAACA,WAAW,CAACU,MAAM,EAAE;QACrBX,QAAQ,CAACY,OAAO,CAACR,OAAO,IAAI;UACxBjB,gBAAgB,CAAC0B,iBAAiB,CAACT,OAAO,CAACU,OAAO,CAAC,CAAC,CAAC;QACzD,CAAC,CAAC;MACN;MACA,OAAOb,WAAW;IACtB,CAAC,CAAC;IACF,MAAMc,SAAS,GAAG,MAAMC,OAAO,CAACC,GAAG,CAAC1B,QAAQ,CAAC;IAC7C,MAAM2B,OAAO,GAAGH,SAAS,CAACI,IAAI,CAAClB,WAAW,IAAIA,WAAW,CAACU,MAAM,KAAK,CAAC,CAAC;IACvE,IAAI,CAACO,OAAO,EAAE;MACV,MAAME,OAAO,GAAGpC,OAAO,CAACoC,OAAO,IAAI,kBAAkB;MACrD,QAAQpC,OAAO,CAACqC,SAAS;QACrB,KAAK,MAAM;UACPlC,gBAAgB,CAACmC,QAAQ,CAAC;YACtBZ,IAAI,EAAE,aAAa;YACnBzB,GAAG;YACHmC,OAAO;YACPG,YAAY,EAAE/C,CAAC,CAACgD,OAAO,CAACT,SAAS;UACrC,CAAC,CAAC;UACF;QACJ,KAAK,eAAe;UAChB,IAAIU,iBAAiB,GAAG,CAAC;UACzB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,SAAS,CAACJ,MAAM,EAAEe,CAAC,EAAE,EAAE;YACvC,IAAIX,SAAS,CAACW,CAAC,CAAC,CAACf,MAAM,GAAGI,SAAS,CAACU,iBAAiB,CAAC,CAACd,MAAM,EAAE;cAC3Dc,iBAAiB,GAAGC,CAAC;YACzB;UACJ;UACAvC,gBAAgB,CAACmC,QAAQ,CAAC;YACtBZ,IAAI,EAAE,aAAa;YACnBzB,GAAG;YACHmC,OAAO;YACPG,YAAY,EAAER,SAAS,CAACU,iBAAiB;UAC7C,CAAC,CAAC;UACF;QACJ,KAAK,SAAS;QACd;UACI;UACAtC,gBAAgB,CAACmC,QAAQ,CAAC;YACtBZ,IAAI,EAAE,qBAAqB;YAC3BzB,GAAG;YACHmC,OAAO;YACPG,YAAY,EAAER;UAClB,CAAC,CAAC;UACF;MACR;IACJ;IACA;IACA,OAAO,MAAM,IAAIrC,OAAO,CAACiD,iBAAiB,CAACxC,gBAAgB,CAAC,CAACL,GAAG,CAACG,GAAG,EAAEC,IAAI,CAAC;EAC/E,CAAC;EACD,MAAM0C,UAAU,GAAGA,CAAC3C,GAAG,EAAE4C,IAAI,EAAEC,IAAI,KAAKhD,GAAG,CAACG,GAAG,CAAC,CAAC8C,IAAI,CAAC,MAAMD,IAAI,CAAC,CAAC,EAAEA,IAAI,CAAC;EACzE,OAAO3D,MAAM,CAAC6D,MAAM,CAACJ,UAAU,EAAE;IAAE9C;EAAI,CAAC,CAAC;AAC7C","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}