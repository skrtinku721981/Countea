{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.selectUnknownFields = exports.selectFields = void 0;\nexports.reconstructFieldPath = reconstructFieldPath;\nconst _ = require(\"lodash\");\nconst selectFields = (req, fields, locations) => _(fields).flatMap(field => _.flatMap(locations, location => {\n  return expandField(req, field, location);\n}))\n// Avoid duplicates if multiple field selections would return the same field twice.\n// E.g. with fields = ['*.foo', 'bar.foo'] and req.body = { bar: { foo: 1 }, baz: { foo: 2 } },\n// the instance bla.foo would appear twice, and baz.foo once.\n.uniqWith(isSameFieldInstance).value();\nexports.selectFields = selectFields;\nfunction isSameFieldInstance(a, b) {\n  return a.path === b.path && a.location === b.location;\n}\nfunction expandField(req, field, location) {\n  const originalPath = field;\n  const pathToExpand = location === 'headers' ? field.toLowerCase() : field;\n  const paths = expandPath(req[location], pathToExpand, []);\n  return paths.map(({\n    path,\n    values\n  }) => {\n    const value = path === '' ? req[location] : _.get(req[location], path);\n    return {\n      location,\n      path,\n      originalPath,\n      pathValues: values,\n      value\n    };\n  });\n}\nfunction expandPath(object, path, currPath, currValues = []) {\n  const segments = _.toPath(path);\n  if (!segments.length) {\n    // no more paths to traverse\n    return [{\n      path: reconstructFieldPath(currPath),\n      values: currValues\n    }];\n  }\n  const key = segments[0];\n  const rest = segments.slice(1);\n  if (object != null && !_.isObjectLike(object)) {\n    if (key === '**') {\n      if (!rest.length) {\n        // globstar leaves are always selected\n        return [{\n          path: reconstructFieldPath(currPath),\n          values: currValues\n        }];\n      }\n      return [];\n    }\n    if (key === '*') {\n      // wildcard position does not exist\n      return [];\n    }\n    // value is a primitive, paths being traversed from here might be in their prototype, return the entire path\n    return [{\n      path: reconstructFieldPath([...currPath, ...segments]),\n      values: currValues\n    }];\n  }\n  // Use a non-null value so that inexistent fields are still selected\n  object = object || {};\n  if (key === '*') {\n    return Object.keys(object).flatMap(key => expandPath(object[key], rest, currPath.concat(key), currValues.concat(key)));\n  }\n  if (key === '**') {\n    return Object.keys(object).flatMap(key => {\n      const nextPath = currPath.concat(key);\n      const value = object[key];\n      // recursively find matching subpaths\n      const selectedPaths = expandPath(value, segments, nextPath, [key]).concat(\n      // skip the first remaining segment, if it matches the current key\n      rest[0] === key ? expandPath(value, rest.slice(1), nextPath, []) : []);\n      return _.uniqBy(selectedPaths, ({\n        path\n      }) => path).map(({\n        path,\n        values\n      }) => ({\n        path,\n        values: values.length ? [...currValues, values.flat()] : currValues\n      }));\n    });\n  }\n  return expandPath(object[key], rest, currPath.concat(key), currValues);\n}\nconst selectUnknownFields = (req, knownFields, locations) => {\n  const tree = {};\n  knownFields.map(field => {\n    const segments = field === '' ? [''] : _.toPath(field);\n    pathToTree(segments, tree);\n  });\n  const instances = [];\n  for (const location of locations) {\n    if (req[location] != null) {\n      instances.push(...findUnknownFields(location, req[location], tree));\n    }\n  }\n  return instances;\n};\nexports.selectUnknownFields = selectUnknownFields;\nfunction pathToTree(segments, tree) {\n  // Will either create or merge into existing branch for the current path segment\n  const branch = tree[segments[0]] || (tree[segments[0]] = {});\n  if (segments.length > 1) {\n    pathToTree(segments.slice(1), branch);\n  } else {\n    // Leaf value.\n    branch[''] = {};\n  }\n}\n/**\n * Performs a depth-first search for unknown fields in `value`.\n * The path to the unknown fields will be pushed to the `unknownFields` argument.\n *\n * Known fields must be passed via `tree`. A field won't be considered unknown if:\n * - its branch is validated as a whole; that is, it contains an empty string key (e.g `{ ['']: {} }`); OR\n * - its path is individually validated; OR\n * - it's covered by a wildcard (`*`).\n *\n * @returns the list of unknown fields\n */\nfunction findUnknownFields(location, value, tree, treePath = [], unknownFields = []) {\n  const globstarBranch = tree['**'];\n  if (tree[''] || globstarBranch?.['']) {\n    // The rest of the tree from here is covered by some validation chain\n    // For example, when the current treePath is `['foo', 'bar']` but `foo` is known\n    return unknownFields;\n  }\n  if (typeof value !== 'object') {\n    if (!treePath.length || globstarBranch) {\n      // This is either\n      // a. a req.body that isn't an object (e.g. `req.body = 'bla'`), and wasn't validated either\n      // b. a leaf value which wasn't the target of a globstar path, e.g. `foo.**.bar`\n      unknownFields.push({\n        path: reconstructFieldPath(treePath),\n        value,\n        location\n      });\n    }\n    return unknownFields;\n  }\n  const wildcardBranch = tree['*'];\n  for (const key of Object.keys(value)) {\n    const keyBranch = tree[key];\n    const path = treePath.concat([key]);\n    if (!keyBranch && !wildcardBranch && !globstarBranch) {\n      // No trees cover this path, so it's an unknown one.\n      unknownFields.push({\n        path: reconstructFieldPath(path),\n        value: value[key],\n        location\n      });\n      continue;\n    }\n    const keyUnknowns = keyBranch ? findUnknownFields(location, value[key], keyBranch, path) : [];\n    const wildcardUnknowns = wildcardBranch ? findUnknownFields(location, value[key], wildcardBranch, path) : [];\n    const globstarUnknowns = globstarBranch ? findUnknownFields(location, value[key], {\n      ['**']: globstarBranch,\n      ...globstarBranch\n    }, path) : [];\n    // If any of the tested branches contain only known fields, then don't mark the fields not covered\n    // by the other branches to the list of unknown ones.\n    // For example, `foo` is more comprehensive than `foo.*.bar`.\n    if ((!keyBranch || keyUnknowns.length) && (!wildcardBranch || wildcardUnknowns.length) && (!globstarBranch || globstarUnknowns.length)) {\n      unknownFields.push(...keyUnknowns, ...wildcardUnknowns, ...globstarUnknowns);\n    }\n  }\n  return unknownFields;\n}\n/**\n * Reconstructs a field path from a list of path segments.\n *\n * Most segments will be concatenated by a dot, for example `['foo', 'bar']` becomes `foo.bar`.\n * However, a numeric segment will be wrapped in brackets to match regular JS array syntax:\n *\n * ```\n * reconstructFieldPath(['foo', 0, 'bar']) // foo[0].bar\n * ```\n *\n * Segments which have a special character such as `.` will be wrapped in brackets and quotes,\n * which also matches JS syntax for objects with such keys.\n *\n * ```\n * reconstructFieldPath(['foo', 'bar.baz', 'qux']) // foo[\"bar.baz\"].qux\n * ```\n */\nfunction reconstructFieldPath(segments) {\n  return segments.reduce((prev, segment) => {\n    let part = '';\n    segment = segment === '\\\\*' ? '*' : segment;\n    // TODO: Handle brackets?\n    if (segment.includes('.')) {\n      // Special char key access\n      part = `[\"${segment}\"]`;\n    } else if (/^\\d+$/.test(segment)) {\n      // Index access\n      part = `[${segment}]`;\n    } else if (prev) {\n      // Object key access\n      part = `.${segment}`;\n    } else {\n      // Top level key\n      part = segment;\n    }\n    return prev + part;\n  }, '');\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","selectUnknownFields","selectFields","reconstructFieldPath","_","require","req","fields","locations","flatMap","field","location","expandField","uniqWith","isSameFieldInstance","a","b","path","originalPath","pathToExpand","toLowerCase","paths","expandPath","map","values","get","pathValues","object","currPath","currValues","segments","toPath","length","key","rest","slice","isObjectLike","keys","concat","nextPath","selectedPaths","uniqBy","flat","knownFields","tree","pathToTree","instances","push","findUnknownFields","branch","treePath","unknownFields","globstarBranch","wildcardBranch","keyBranch","keyUnknowns","wildcardUnknowns","globstarUnknowns","reduce","prev","segment","part","includes","test"],"sources":["D:/test/textutils/node_modules/express-validator/lib/field-selection.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.selectUnknownFields = exports.selectFields = void 0;\nexports.reconstructFieldPath = reconstructFieldPath;\nconst _ = require(\"lodash\");\nconst selectFields = (req, fields, locations) => _(fields)\n    .flatMap(field => _.flatMap(locations, location => {\n    return expandField(req, field, location);\n}))\n    // Avoid duplicates if multiple field selections would return the same field twice.\n    // E.g. with fields = ['*.foo', 'bar.foo'] and req.body = { bar: { foo: 1 }, baz: { foo: 2 } },\n    // the instance bla.foo would appear twice, and baz.foo once.\n    .uniqWith(isSameFieldInstance)\n    .value();\nexports.selectFields = selectFields;\nfunction isSameFieldInstance(a, b) {\n    return a.path === b.path && a.location === b.location;\n}\nfunction expandField(req, field, location) {\n    const originalPath = field;\n    const pathToExpand = location === 'headers' ? field.toLowerCase() : field;\n    const paths = expandPath(req[location], pathToExpand, []);\n    return paths.map(({ path, values }) => {\n        const value = path === '' ? req[location] : _.get(req[location], path);\n        return {\n            location,\n            path,\n            originalPath,\n            pathValues: values,\n            value,\n        };\n    });\n}\nfunction expandPath(object, path, currPath, currValues = []) {\n    const segments = _.toPath(path);\n    if (!segments.length) {\n        // no more paths to traverse\n        return [\n            {\n                path: reconstructFieldPath(currPath),\n                values: currValues,\n            },\n        ];\n    }\n    const key = segments[0];\n    const rest = segments.slice(1);\n    if (object != null && !_.isObjectLike(object)) {\n        if (key === '**') {\n            if (!rest.length) {\n                // globstar leaves are always selected\n                return [\n                    {\n                        path: reconstructFieldPath(currPath),\n                        values: currValues,\n                    },\n                ];\n            }\n            return [];\n        }\n        if (key === '*') {\n            // wildcard position does not exist\n            return [];\n        }\n        // value is a primitive, paths being traversed from here might be in their prototype, return the entire path\n        return [\n            {\n                path: reconstructFieldPath([...currPath, ...segments]),\n                values: currValues,\n            },\n        ];\n    }\n    // Use a non-null value so that inexistent fields are still selected\n    object = object || {};\n    if (key === '*') {\n        return Object.keys(object).flatMap(key => expandPath(object[key], rest, currPath.concat(key), currValues.concat(key)));\n    }\n    if (key === '**') {\n        return Object.keys(object).flatMap(key => {\n            const nextPath = currPath.concat(key);\n            const value = object[key];\n            // recursively find matching subpaths\n            const selectedPaths = expandPath(value, segments, nextPath, [key]).concat(\n            // skip the first remaining segment, if it matches the current key\n            rest[0] === key ? expandPath(value, rest.slice(1), nextPath, []) : []);\n            return _.uniqBy(selectedPaths, ({ path }) => path).map(({ path, values }) => ({\n                path,\n                values: values.length ? [...currValues, values.flat()] : currValues,\n            }));\n        });\n    }\n    return expandPath(object[key], rest, currPath.concat(key), currValues);\n}\nconst selectUnknownFields = (req, knownFields, locations) => {\n    const tree = {};\n    knownFields.map(field => {\n        const segments = field === '' ? [''] : _.toPath(field);\n        pathToTree(segments, tree);\n    });\n    const instances = [];\n    for (const location of locations) {\n        if (req[location] != null) {\n            instances.push(...findUnknownFields(location, req[location], tree));\n        }\n    }\n    return instances;\n};\nexports.selectUnknownFields = selectUnknownFields;\nfunction pathToTree(segments, tree) {\n    // Will either create or merge into existing branch for the current path segment\n    const branch = tree[segments[0]] || (tree[segments[0]] = {});\n    if (segments.length > 1) {\n        pathToTree(segments.slice(1), branch);\n    }\n    else {\n        // Leaf value.\n        branch[''] = {};\n    }\n}\n/**\n * Performs a depth-first search for unknown fields in `value`.\n * The path to the unknown fields will be pushed to the `unknownFields` argument.\n *\n * Known fields must be passed via `tree`. A field won't be considered unknown if:\n * - its branch is validated as a whole; that is, it contains an empty string key (e.g `{ ['']: {} }`); OR\n * - its path is individually validated; OR\n * - it's covered by a wildcard (`*`).\n *\n * @returns the list of unknown fields\n */\nfunction findUnknownFields(location, value, tree, treePath = [], unknownFields = []) {\n    const globstarBranch = tree['**'];\n    if (tree[''] || globstarBranch?.['']) {\n        // The rest of the tree from here is covered by some validation chain\n        // For example, when the current treePath is `['foo', 'bar']` but `foo` is known\n        return unknownFields;\n    }\n    if (typeof value !== 'object') {\n        if (!treePath.length || globstarBranch) {\n            // This is either\n            // a. a req.body that isn't an object (e.g. `req.body = 'bla'`), and wasn't validated either\n            // b. a leaf value which wasn't the target of a globstar path, e.g. `foo.**.bar`\n            unknownFields.push({\n                path: reconstructFieldPath(treePath),\n                value,\n                location,\n            });\n        }\n        return unknownFields;\n    }\n    const wildcardBranch = tree['*'];\n    for (const key of Object.keys(value)) {\n        const keyBranch = tree[key];\n        const path = treePath.concat([key]);\n        if (!keyBranch && !wildcardBranch && !globstarBranch) {\n            // No trees cover this path, so it's an unknown one.\n            unknownFields.push({\n                path: reconstructFieldPath(path),\n                value: value[key],\n                location,\n            });\n            continue;\n        }\n        const keyUnknowns = keyBranch ? findUnknownFields(location, value[key], keyBranch, path) : [];\n        const wildcardUnknowns = wildcardBranch\n            ? findUnknownFields(location, value[key], wildcardBranch, path)\n            : [];\n        const globstarUnknowns = globstarBranch\n            ? findUnknownFields(location, value[key], { ['**']: globstarBranch, ...globstarBranch }, path)\n            : [];\n        // If any of the tested branches contain only known fields, then don't mark the fields not covered\n        // by the other branches to the list of unknown ones.\n        // For example, `foo` is more comprehensive than `foo.*.bar`.\n        if ((!keyBranch || keyUnknowns.length) &&\n            (!wildcardBranch || wildcardUnknowns.length) &&\n            (!globstarBranch || globstarUnknowns.length)) {\n            unknownFields.push(...keyUnknowns, ...wildcardUnknowns, ...globstarUnknowns);\n        }\n    }\n    return unknownFields;\n}\n/**\n * Reconstructs a field path from a list of path segments.\n *\n * Most segments will be concatenated by a dot, for example `['foo', 'bar']` becomes `foo.bar`.\n * However, a numeric segment will be wrapped in brackets to match regular JS array syntax:\n *\n * ```\n * reconstructFieldPath(['foo', 0, 'bar']) // foo[0].bar\n * ```\n *\n * Segments which have a special character such as `.` will be wrapped in brackets and quotes,\n * which also matches JS syntax for objects with such keys.\n *\n * ```\n * reconstructFieldPath(['foo', 'bar.baz', 'qux']) // foo[\"bar.baz\"].qux\n * ```\n */\nfunction reconstructFieldPath(segments) {\n    return segments.reduce((prev, segment) => {\n        let part = '';\n        segment = segment === '\\\\*' ? '*' : segment;\n        // TODO: Handle brackets?\n        if (segment.includes('.')) {\n            // Special char key access\n            part = `[\"${segment}\"]`;\n        }\n        else if (/^\\d+$/.test(segment)) {\n            // Index access\n            part = `[${segment}]`;\n        }\n        else if (prev) {\n            // Object key access\n            part = `.${segment}`;\n        }\n        else {\n            // Top level key\n            part = segment;\n        }\n        return prev + part;\n    }, '');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}