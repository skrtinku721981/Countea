{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Context = void 0;\nconst _ = require(\"lodash\");\nfunction getDataMapKey(path, location) {\n  return `${location}:${path}`;\n}\nclass Context {\n  get errors() {\n    return this._errors;\n  }\n  constructor(fields, locations, stack, optional, bail, visibility = {\n    type: 'visible'\n  }, message) {\n    this.fields = fields;\n    this.locations = locations;\n    this.stack = stack;\n    this.optional = optional;\n    this.bail = bail;\n    this.visibility = visibility;\n    this.message = message;\n    this._errors = [];\n    this.dataMap = new Map();\n  }\n  getData(options = {\n    requiredOnly: false\n  }) {\n    const {\n      optional\n    } = this;\n    const checks = options.requiredOnly && optional ? [value => value !== undefined, value => optional === 'null' ? value != null : true, value => optional === 'falsy' ? value : true] : [];\n    return _([...this.dataMap.values()]).groupBy('originalPath').flatMap((instances, group) => {\n      const locations = _.uniqBy(instances, 'location');\n      // #331 - When multiple locations are involved, all of them must pass the validation.\n      // If none of the locations contain the field, we at least include one for error reporting.\n      // #458, #531 - Wildcards are an exception though: they may yield 0..* instances with different\n      // paths, so we may want to skip this filtering.\n      if (instances.length > 1 && locations.length > 1 && !group.includes('*')) {\n        const withValue = instances.filter(instance => instance.value !== undefined);\n        return withValue.length ? withValue : [instances[0]];\n      }\n      return instances;\n    }).filter(instance => checks.every(check => check(instance.value))).valueOf();\n  }\n  addFieldInstances(instances) {\n    instances.forEach(instance => {\n      this.dataMap.set(getDataMapKey(instance.path, instance.location), {\n        ...instance\n      });\n    });\n  }\n  setData(path, value, location) {\n    const instance = this.dataMap.get(getDataMapKey(path, location));\n    if (!instance) {\n      throw new Error('Attempt to write data that did not pre-exist in context');\n    }\n    instance.value = value;\n  }\n  addError(opts) {\n    const msg = opts.message || this.message || 'Invalid value';\n    let error;\n    switch (opts.type) {\n      case 'field':\n        error = this.updateVisibility({\n          type: 'field',\n          value: opts.value,\n          msg: typeof msg === 'function' ? msg(opts.value, opts.meta) : msg,\n          path: opts.meta?.path,\n          location: opts.meta?.location\n        });\n        break;\n      case 'unknown_fields':\n        error = {\n          type: 'unknown_fields',\n          msg: typeof msg === 'function' ? msg(opts.fields, {\n            req: opts.req\n          }) : msg,\n          fields: opts.fields\n        };\n        break;\n      case 'alternative':\n        error = {\n          type: 'alternative',\n          msg: typeof msg === 'function' ? msg(opts.nestedErrors, {\n            req: opts.req\n          }) : msg,\n          nestedErrors: opts.nestedErrors.map(error => this.updateVisibility(error))\n        };\n        break;\n      case 'alternative_grouped':\n        error = {\n          type: 'alternative_grouped',\n          msg: typeof msg === 'function' ? msg(opts.nestedErrors, {\n            req: opts.req\n          }) : msg,\n          nestedErrors: opts.nestedErrors.map(errors => errors.map(error => this.updateVisibility(error)))\n        };\n        break;\n      default:\n        throw new Error(`Unhandled addError case`);\n    }\n    this._errors.push(error);\n  }\n  updateVisibility(error) {\n    switch (this.visibility.type) {\n      case 'hidden':\n        error = {\n          ...error\n        };\n        delete error.value;\n        return error;\n      case 'redacted':\n        return {\n          ...error,\n          value: this.visibility.value\n        };\n      case 'visible':\n      default:\n        return error;\n    }\n  }\n}\nexports.Context = Context;","map":{"version":3,"names":["Object","defineProperty","exports","value","Context","_","require","getDataMapKey","path","location","errors","_errors","constructor","fields","locations","stack","optional","bail","visibility","type","message","dataMap","Map","getData","options","requiredOnly","checks","undefined","values","groupBy","flatMap","instances","group","uniqBy","length","includes","withValue","filter","instance","every","check","valueOf","addFieldInstances","forEach","set","setData","get","Error","addError","opts","msg","error","updateVisibility","meta","req","nestedErrors","map","push"],"sources":["D:/test/textutils/node_modules/express-validator/lib/context.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Context = void 0;\nconst _ = require(\"lodash\");\nfunction getDataMapKey(path, location) {\n    return `${location}:${path}`;\n}\nclass Context {\n    get errors() {\n        return this._errors;\n    }\n    constructor(fields, locations, stack, optional, bail, visibility = { type: 'visible' }, message) {\n        this.fields = fields;\n        this.locations = locations;\n        this.stack = stack;\n        this.optional = optional;\n        this.bail = bail;\n        this.visibility = visibility;\n        this.message = message;\n        this._errors = [];\n        this.dataMap = new Map();\n    }\n    getData(options = { requiredOnly: false }) {\n        const { optional } = this;\n        const checks = options.requiredOnly && optional\n            ? [\n                (value) => value !== undefined,\n                (value) => (optional === 'null' ? value != null : true),\n                (value) => (optional === 'falsy' ? value : true),\n            ]\n            : [];\n        return _([...this.dataMap.values()])\n            .groupBy('originalPath')\n            .flatMap((instances, group) => {\n            const locations = _.uniqBy(instances, 'location');\n            // #331 - When multiple locations are involved, all of them must pass the validation.\n            // If none of the locations contain the field, we at least include one for error reporting.\n            // #458, #531 - Wildcards are an exception though: they may yield 0..* instances with different\n            // paths, so we may want to skip this filtering.\n            if (instances.length > 1 && locations.length > 1 && !group.includes('*')) {\n                const withValue = instances.filter(instance => instance.value !== undefined);\n                return withValue.length ? withValue : [instances[0]];\n            }\n            return instances;\n        })\n            .filter(instance => checks.every(check => check(instance.value)))\n            .valueOf();\n    }\n    addFieldInstances(instances) {\n        instances.forEach(instance => {\n            this.dataMap.set(getDataMapKey(instance.path, instance.location), { ...instance });\n        });\n    }\n    setData(path, value, location) {\n        const instance = this.dataMap.get(getDataMapKey(path, location));\n        if (!instance) {\n            throw new Error('Attempt to write data that did not pre-exist in context');\n        }\n        instance.value = value;\n    }\n    addError(opts) {\n        const msg = opts.message || this.message || 'Invalid value';\n        let error;\n        switch (opts.type) {\n            case 'field':\n                error = this.updateVisibility({\n                    type: 'field',\n                    value: opts.value,\n                    msg: typeof msg === 'function' ? msg(opts.value, opts.meta) : msg,\n                    path: opts.meta?.path,\n                    location: opts.meta?.location,\n                });\n                break;\n            case 'unknown_fields':\n                error = {\n                    type: 'unknown_fields',\n                    msg: typeof msg === 'function' ? msg(opts.fields, { req: opts.req }) : msg,\n                    fields: opts.fields,\n                };\n                break;\n            case 'alternative':\n                error = {\n                    type: 'alternative',\n                    msg: typeof msg === 'function' ? msg(opts.nestedErrors, { req: opts.req }) : msg,\n                    nestedErrors: opts.nestedErrors.map(error => this.updateVisibility(error)),\n                };\n                break;\n            case 'alternative_grouped':\n                error = {\n                    type: 'alternative_grouped',\n                    msg: typeof msg === 'function' ? msg(opts.nestedErrors, { req: opts.req }) : msg,\n                    nestedErrors: opts.nestedErrors.map(errors => errors.map(error => this.updateVisibility(error))),\n                };\n                break;\n            default:\n                throw new Error(`Unhandled addError case`);\n        }\n        this._errors.push(error);\n    }\n    updateVisibility(error) {\n        switch (this.visibility.type) {\n            case 'hidden':\n                error = { ...error };\n                delete error.value;\n                return error;\n            case 'redacted':\n                return {\n                    ...error,\n                    value: this.visibility.value,\n                };\n            case 'visible':\n            default:\n                return error;\n        }\n    }\n}\nexports.Context = Context;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}